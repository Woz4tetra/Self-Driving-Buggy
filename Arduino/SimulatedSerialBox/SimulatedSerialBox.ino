
/**
 *  @file SerialBox.ino
 *  
 *  Self Driving Buggy sensor board drivers and serial communication
 *  
 *  @author Ben Warwick
 *  @author Nat Jeffries
 *  Add yourselves to authors field upon contribution!
 *  
 *  In order to run this code you need the following libraries:
 *  https://github.com/ivanseidel/DueTimer
 *  MPU6050 drivers (built-in ?)
 *  Wire.h libary (built-in)
 *  /ben_projects/Self-Driving\ Buggy\ Rev.\ 6/board/test_serial.py
 *  
 */

#include "SerialPacket.h"
#include "defines.h"

/* ================================================== *
 *                  Global constants                  *
 * ================================================== */

/* ------------- Autogenerated constants ------------ */

/* Command IDs start */
#define GYRO_ID 0x00
#define GPS_ID 0x01
#define ENCODER_ID 0x02
#define SERVO_ID 0x03
#define LED13_ID 0x04
/* Command IDs end */


/* Enables start */
#define ENABLE_GYRO
#define ENABLE_GPS
#define ENABLE_ENCODER
#define ENABLE_SERVO
#define ENABLE_LED13
/* Enables end */

/* -------------- Serial Packet Globals ------------- */
uint8_t command_id = 0;
uint8_t payload = 0;

SerialPacket Packet;

/* ---------------- LED 13 Globals ------------------ */
#define LED13_PIN 13

/* ----------------- Servo Globals ------------------ */

/* -------------- GPS Globals/Pre-setup ------------- */
#ifdef ENABLE_GPS

uint8_t gps_array[8]; // 4 * 2, 2 float numbers | old: 4 * 4 + 2 * 1, 4 float numbers and 2 int numbers
// sending floats: longitude, latitude

float gps_float_array[4];

#endif

/* -------------- IMU Globals/Pre-setup ------------- */

#ifdef ENABLE_GYRO

int16_t gx, gy, gz;

uint8_t gyro_array[6];
float gyro_float_array[3];

#endif

/* ------- Distance encoder Globals/Pre-setup ------- */
#ifdef ENABLE_ENCODER
uint16_t distance; // counts of the encoder

#endif

/* ================================================== *
 *                       Setup                        *
 * ================================================== */

void setup()
{
    /* ---------------- Serial Setup ---------------- */
    handshake();
}

void handshake()
{
    pinMode(LED13_PIN, OUTPUT);
    
    Packet.begin(115200, 2);
    Serial.print("R");  // Send ready flag
    while (Serial.available() <= 0) {  }
    
    Serial.flush();
}

/* ================================================== *
 *                  Loop and Serial                   *
 * ================================================== */

void loop()
{
//    delay(3);
}

/*
 SerialEvent occurs whenever a new data comes in the
 hardware serial RX.  This routine is run between each
 time loop() runs, so using delay inside loop can delay
 response.  Multiple bytes of data may be available.
 */
void serialEvent()
{
    /* ---------------- Read Serial ----------------- */
    int result = Packet.readSerialData();
    // if result == 0, misformed packet, don't do anything
    if (result == 1)
    {
        command_id = Packet.getCommandID();
        payload = Packet.getPayload();
        
        while (Serial.read() > 0) {  }
        Serial.flush();
    }
    else if (result == 2)
    {
        /* -------------- Read Led 13 --------------- */
        if (command_id == LED13_ID)
        {
            digitalWrite(LED13_PIN, payload);
            Packet.sendCommandReply(command_id, payload);
        }
        /* ------------ Read IMU Simple ------------- */
#ifdef ENABLE_GYRO
        else if (command_id == ENABLE_GYRO)
        {
            delay(1);
//            ax = random(-0x8000, 0x8000 - 1);
//            ay = random(-0x8000, 0x8000 - 1);
//            az = random(-0x8000, 0x8000 - 1);
            gx = random(-0x8000, 0x8000 - 1);
            gy = random(-0x8000, 0x8000 - 1);
            gz = random(-0x8000, 0x8000 - 1);

//            accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);
            gyro_array[0] = gx >> 8;
            gyro_array[1] = gx & 0xffff;
            gyro_array[2] = gy >> 8;
            gyro_array[3] = gy & 0xffff;
            gyro_array[4] = gz >> 8;
            gyro_array[5] = gz & 0xffff;
            
            Packet.sendDataArray(gyro_array, 6);
        }
#endif
        
        /* ------------- Read Encoder -------------- */
#ifdef ENABLE_ENCODER
        else if (command_id == ENCODER_ID)
        {
            delay(1);
            distance += 1;
            Packet.sendData16bit(distance);
        }
#endif
      
        /* -------------- Read Servo --------------- */
#ifdef ENABLE_SERVO
        else if (command_id == SERVO_ID)
        {
            delay(1);
            Packet.sendCommandReply(command_id, payload);
        }
#endif
        /* --------------- Read GPS ---------------- */
#ifdef ENABLE_GPS
        else if (command_id == GPS_ID)
        {
            delay(1);            
            
            gps_float_array[0] = rand();
            gps_float_array[1] = rand();
            //gps_float_array[2] = GPS.speed;
            //gps_float_array[3] = GPS.angle;
            
            for (int float_index = 0; float_index < 2; float_index++) {
                to_hex(gps_float_array[float_index], gps_array, float_index);
            }
            
            //gps_array[16] = (uint8_t)GPS.satellites;
            //gps_array[17] = (uint8_t)GPS.fixquality;
            
            Packet.sendDataArray(gps_array, 8);
        }
#endif
    }
}

void to_hex(float input, uint8_t *array, int start)
{
    byte* bytearray = (byte*) &input;
    short float_length = 4;
    start *= float_length;
    
    for (int index = float_length - 1; index >= 0; index--) {
        array[((float_length - 1) - index) + start] = bytearray[index];
    }
}
