#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     IRvalue,        sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     motorBottomRight, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorBottomLeft, tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorTopRight, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     motorTopLeft,  tmotorTetrix, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Unlike past programs, this one utilizes distance formula, arctan(), and a refined correctAngle() function

#include "C:\Program Files (x86)\Robomatter Inc\ROBOTC Development Environment\Sample Programs\NXT\3rd Party Sensor Drivers\drivers\hitechnic-irseeker-v2.h"

//--------------------------------------------------------------------
//											Global Variable definitions
//--------------------------------------------------------------------

// Conversion from encoder value to centimeters
float encoderToCM = 60.52;
float robotRadius = 12.33;

float startingX = 0;
float startingY = 0;

//--------------------------------------------------------------------
//												Motor Direction Methods
//--------------------------------------------------------------------

void stopMotors()
{
    motor[motorBottomLeft]  = 0;
    motor[motorBottomRight] = 0;
    motor[motorTopLeft]     = 0;
    motor[motorTopRight]    = 0;
}

void driveForward(int speed)
{
		motor[motorBottomLeft]  =  speed;
    motor[motorBottomRight] =  speed;
    motor[motorTopLeft]     =  speed;
    motor[motorTopRight]    =  speed;
}

void rotateLeft(int speed)
{
    motor[motorBottomLeft] 	= -speed;
    motor[motorBottomRight] = -speed;
    motor[motorTopLeft]     =  speed;
    motor[motorTopRight]    =  speed;
}

void rotateRight(int speed)
{
    motor[motorBottomLeft] 	=  speed;
    motor[motorBottomRight] =  speed;
    motor[motorTopLeft]     = -speed;
    motor[motorTopRight]    = -speed;
}

//--------------------------------------------------------------------
//													"goTo" methods
//--------------------------------------------------------------------

float convertToDegrees (float angle)
{
	return angle * 180 / PI;
}

float convertToRadians (float angle)
{
	return angle * PI / 180;
}

float correctAngle (float angle)
{
    if (angle < -PI)
    {
        angle += 2 * PI;
    }
    if (angle >= PI)
    {
        angle -= 2 * PI;
    }
    return angle;
}

float getHeading(float encoderCounts)
{
    // returns angle in degrees
    return correctAngle ( (encoderCounts / encoderToCM) / robotRadius);
}

void goToAngle(float turnAngle)
{
	// if goal heading does not equal current heading, turn left or right
	while (convertToDegrees( turnAngle ) - convertToDegrees( getHeading( (nMotorEncoder[motorTopLeft] - nMotorEncoder[motorBottomLeft]) / 2 ) ) >= 0 ) //method getHeading() doesn't work if nMotorEncoder is not a parameter
	{
		if (convertToDegrees( turnAngle ) > convertToDegrees( getHeading( (nMotorEncoder[motorTopLeft] - nMotorEncoder[motorBottomLeft]) / 2 ) ) ) // "-" indicates rotation
		{
			rotateLeft(15);
		}
		else
		{
			rotateRight(15);
		}
		//writeDebugStreamLine("\nHeading: %f", convertToDegrees (getHeading( (nMotorEncoder[motorTopLeft] - nMotorEncoder[motorBottomLeft] ) / 2) ) );
  //      writeDebugStreamLine("TurnAngle: %f", convertToDegrees( turnAngle ) );
	}
	stopMotors();
	wait1Msec(500);
}

void goToDistance(float radius)
{
	while (	( ( (nMotorEncoder[motorTopLeft] + nMotorEncoder[motorBottomLeft] ) / 2 ) / encoderToCM ) < radius ) // "+" indicates forward or backward motion
	{
		driveForward(25);
		writeDebugStreamLine("\nDistance: %f", ( (nMotorEncoder[motorTopLeft] + nMotorEncoder[motorBottomLeft] ) / 2 ) / encoderToCM );
        writeDebugStreamLine("Radius: %f", radius);
	}
	stopMotors();
	wait1Msec(500);
}

//--------------------------------------------------------------------
//										Angle and Distance calculation methods
//--------------------------------------------------------------------

float getGoalDistance (float inputX, float inputY, float currentX, float currentY)
{
    //distance formula
    return sqrt ( pow (inputY - currentY, 2) + pow (inputX - currentX, 2) );
}

float getGoalAngle (float inputX, float inputY, float currentX, float currentY)
{
	// arctan
    return atan ( (inputY - currentY) / (inputX - currentX) );
}

void goToPoint (float inputX, float inputY) // inputAngle in degrees, rest of method converted to radians
{
    static float currentX;
    static float currentY;
    static float currentAngle;

    float radius;
    float goalAngle;

    nMotorEncoder[motorBottomLeft] = 0;
    nMotorEncoder[motorTopLeft] = 0;

    inputX += startingX;
    inputY += startingY;

    //(float inputX, float inputY, float currentX, float currentY)
    radius = getGoalDistance (inputX, inputY, currentX, currentY);

    //(float inputX, float inputY, float currentX, float currentY)
    goalAngle = getGoalAngle (inputX, inputY, currentX, currentY);

    if (inputX < currentX)
    {
        goalAngle += PI;
    }

    float turnAngle = correctAngle(goalAngle - currentAngle);

    writeDebugStreamLine ("\n------------------------");
    writeDebugStreamLine ("turnAngle: %f", turnAngle);
    writeDebugStreamLine ("radius: %f", radius);

    //-------------------------------------
    goToAngle (turnAngle);

    nMotorEncoder[motorBottomLeft] = 0;
    nMotorEncoder[motorTopLeft] = 0;

    //-------------------------------------
    goToDistance (radius);

    nMotorEncoder[motorBottomLeft] = 0;
    nMotorEncoder[motorTopLeft] = 0;

    //-------------------------------------

    currentX = inputX;
    currentY = inputY;
    currentAngle = goalAngle;

    writeDebugStreamLine ("currentX: %f", currentX);
    writeDebugStreamLine ("currentY: %f", currentY);
}

//-------------------------------------------------
//										IR Methods
//-------------------------------------------------

int DCsector1, DCsector2, DCsector3, DCsector4, DCsector5;

task updateIRSensor()
{
	while(true)
	{
		if (!HTIRS2readAllDCStrength(IRvalue, DCsector1, DCsector2, DCsector3, DCsector4, DCsector5))
	     StopAllTasks(); // I2C read error occurred
	}
}

task main()
{
		StartTask(updateIRSensor);

		while(true)
		{
			writeDebugStreamLine("\nDCsector3: %i", DCsector3);
			writeDebugStreamLine("DCsector4: %i", DCsector4);
		}

    goToPoint(20, 20);
    goToPoint(-20, 20);
    goToPoint(-20, -20);
    goToPoint(20, -20);
    goToPoint(0, 0);
}
